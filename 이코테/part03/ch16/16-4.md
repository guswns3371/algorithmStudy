# [병사 배치하기](https://www.acmicpc.net/problem/18353)

## 문제 설명

* N명의 병사가 무작위로 나열되어있고, 병사를 배치할 떄 전투력이 높은 병사가 앞쪽에 오도록 내림차순으로 배치하려고 한다.
    * 즉, 앞쪽에 있는 병사의 전투력이 항상 뒤쪽에 있는 병사보다 높아야 한다.

* 배치과정에서는 특정한 위치에 있는 병사를 열외시키는 방법을 이용한다.
    * 그럼과 동시에 남아있는 병사의 수가 최대가 되도록 한다.

* 해당 조건을 만족하기 위해 열외시켜야 하는 병사의 수를 출력하라.

## 코드

### 2차시도([성공](https://www.acmicpc.net/status?user_id=guswns3371&problem_id=18353&from_mine=1))

```python
n = int(input())
army = list(map(int, input().split()))
array = [i for i in range(n)]
dp = [-1 for _ in range(n)]

for i in reversed(range(n)):
    combat = army[i]  # 현재 방문한 병사의 전투력
    behind_solider = array[i + 1:]  # 현재 방문한 병사보다 뒤에 있는 병사들의 인덱스
    max_idx = -1  # 현재 방문한 병사보다 전투력이 낮은 병사들중 가장 높은 전투력을 가진 병사의 인덱스
    max_dp = -1  # army[max_idx]

    for j in behind_solider:
        if combat > army[j]:  # 현재 방문한 병사보다 전투력이 작은 병사들 중
            if max_dp < dp[j]:  # dp 값이 높은 병사의
                max_dp = dp[j]  # 전투력을 max_combat 에 담고
                max_idx = j  # 인덱스를 max_idx에 담는다

    if max_idx == -1:  # 조건에 맞는 병사가 없다면
        dp[i] = 1
    else:
        dp[i] = dp[max_idx] + 1

print(n - max(dp))
```

1. 초기상태

* dp table은 모두 -1로 초기화 되어있다.
    * dp[i]의 의미
        * i번쨰 병사보다 뒤에 있고, 전투력이 낮은 병사들 중 dp값이 높은 병사의 수 + 자기자신(1명)
        * 다시 말해, i번째 병사부터 마지막 병사들 중 고를 수 있는 병사의 수
* 병사 번호 6번부터 0번까지 역순으로 dp 테이블을 채워 나간다.

|병사번호|0|1|2|3|4|5|6|
|---|---|---|---|---|---|---|---|
|전투력|15|11|4|8|5|2|4|
|dp|-1|-1|-1|-1|-1|-1|-1|

2. 6번 병사

* 6번 병사보다 뒤에 있고, 전투력이 낮은 병사들 중 dp 값이 큰 병사는 존재하지 않는다.
* 따라서 dp[6] = 1을 설정한다.

|병사번호|0|1|2|3|4|5|6|
|---|---|---|---|---|---|---|---|
|전투력|15|11|4|8|5|2|4|
|dp|-1|-1|-1|-1|-1|-1|1|

3. 5번 병사

* 5번 병사보다 뒤에 있고, 전투력이 낮은 병사들 중 dp 값이 큰 병사는 존재하지 않는다.
* 따라서 dp[5] = 1을 설정한다.

|병사번호|0|1|2|3|4|5|6|
|---|---|---|---|---|---|---|---|
|전투력|15|11|4|8|5|2|4|
|dp|-1|-1|-1|-1|-1|1|1|

4. 4번 병사

* 4번 병사보다 뒤에 있고, 전투력이 낮은 병사들 중 dp 값이 큰 병사는 5번 또는 6번이다.
* 따라서 dp[4] = dp[5] +1 = dp[6] +1 = 2을 설정한다.

|병사번호|0|1|2|3|4|5|6|
|---|---|---|---|---|---|---|---|
|전투력|15|11|4|8|5|2|4|
|dp|-1|-1|-1|-1|2|1|1|

> * dp[4]의 의미는 무엇인가?
    >
* army[4:] 만 고려해보자.
>    * 병사 번호 4번부터 6번에 대해서 4번 병사의 전투력보다 작은 병사들은 5번과 6번이다.
>    * 5번과 6번 중에서 dp값이 가장 큰 병사를 찾아야한다.
       >
* 이 경우에는 dp[5] == dp[6] == 1 으로 같다.
>    * dp[4] = dp[5] +1 = dp[6] +1 = 2로 설정한다.
       >
* 즉, dp[4] 는 4번부터 6번까지의 병사들 중에서 내림차순 배치를 만족하면서 최대로 고를 수 있는병사의 수이다.

|병사번호|4|5|6|
|---|---|---|---|
|전투력|5|2|4|
|dp|2|1|1|

5. 3번 병사

* 3번 병사보다 뒤에 있고, 전투력이 낮은 병사들 중 dp 값이 큰 병사는 4번이다.
* 따라서 dp[3] = dp[4] +1 = 3을 설정한다.

|병사번호|0|1|2|3|4|5|6|
|---|---|---|---|---|---|---|---|
|전투력|15|11|4|8|5|2|4|
|dp|-1|-1|-1|3|2|1|1|

6. 2번 병사

* 2번 병사보다 뒤에 있고, 전투력이 낮은 병사들 중 dp 값이 큰 병사는 5번이다.
* 따라서 dp[2] = dp[5] +1 = 2을 설정한다.

|병사번호|0|1|2|3|4|5|6|
|---|---|---|---|---|---|---|---|
|전투력|15|11|4|8|5|2|4|
|dp|-1|-1|2|3|2|1|1|

7. 1번 병사

* 1번 병사보다 뒤에 있고, 전투력이 낮은 병사들 중 dp 값이 큰 병사는 3번이다.
* 따라서 dp[1] = dp[2] +1 = 4을 설정한다.

|병사번호|0|1|2|3|4|5|6|
|---|---|---|---|---|---|---|---|
|전투력|15|11|4|8|5|2|4|
|dp|-1|4|2|3|2|1|1|

8. 0번 병사

* 0번 병사보다 뒤에 있고, 전투력이 낮은 병사들 중 dp 값이 큰 병사는 1번이다.
* 따라서 dp[0] = dp[1] +1 = 5을 설정한다.

|병사번호|0|1|2|3|4|5|6|
|---|---|---|---|---|---|---|---|
|전투력|15|11|4|8|5|2|4|
|dp|5|4|2|3|2|1|1|

---

* max(dp) : 전투력을 기준으로 내림차순 배열이 되도록 고를 수 있는 병사 수중 최댓값이다.
    * 열외 시킬 병사의 수는 n - max(dp)이다.

---

## [모범 답안](https://github.com/ndb796/python-for-coding-test/blob/master/16/4.py)

```python
n = int(input())
array = list(map(int, input().split()))
# 순서를 뒤집어 '최장 증가 부분 수열' 문제로 변환
array.reverse()

# 다이나믹 프로그래밍을 위한 1차원 DP 테이블 초기화
dp = [1] * n

# 가장 긴 증가하는 부분 수열(LIS) 알고리즘 수행
for i in range(1, n):
    for j in range(0, i):
        if array[j] < array[i]:
            dp[i] = max(dp[i], dp[j] + 1)

# 열외해야 하는 병사의 최소 수를 출력
print(n - max(dp))
```