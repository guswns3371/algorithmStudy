# ìµœë‹¨ê²½ë¡œ

# ê°€ì¥ ë¹ ë¥¸ ê¸¸ ì°¾ê¸°

## ê°€ì¥ ë¹ ë¥´ê²Œ ë„ë‹¬í•˜ëŠ” ë°©ë²•

- ìµœë‹¨ê²½ë¡œ : ê°€ì¥ ì§§ì€ ê²½ë¡œë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜

> 1. ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ âœ”
>
> 2. í”Œë¡œì´ë“œ ì›Œì…œ âœ”
> 3. ë²¨ë§Œ í¬ë“œ ì•Œê³ ë¦¬ì¦˜

## ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜

- ê·¸ë˜í”„ì—ì„œ ì—¬ëŸ¬ê°œì˜ ë…¸ë“œê°€ ìˆì„ ë–„, íŠ¹ì •í•œ ë…¸ë“œì—ì„œ ì¶œë°œí•˜ì—¬ ë‹¤ë¥¸ ë…¸ë“œë¡œ ê°€ëŠ” ê°ê°ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜

- **ìŒì˜ ê°„ì„ **ì´ ì—†ì„ ë•Œ ì •ìƒì ìœ¼ë¡œ ë™ì‘
    - ìŒì˜ ê°„ì„  : 0ë³´ë‹¤ ì‘ì€ ê°’ì„ ê°–ëŠ” ê°„ì„ 
- ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ì˜ í•œ ì¢…ë¥˜ : ê°€ì¥ ë¹„ìš©ì´ ì ì€ ë…¸ë“œë¥¼ ì„ íƒí•´ì„œ ì„ì˜ì˜ ê³¼ì •ì„ ë°˜ë³µí•˜ê¸° ë•Œë¬¸

### ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ ì›ë¦¬

> 1. ì¶œë°œ ë…¸ë“œë¥¼ ì„¤ì •í•œë‹¤.
>
> 2. **ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸”**ì„ ì´ˆê¸°í™”í•œë‹¤.
> 3. ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œì¤‘ ìµœë‹¨ ê±°ë¦¬ê°€ ê°€ì¥ ì§§ì€ ë…¸ë“œë¥¼ ì„ íƒí•œë‹¤.
> 4. í•´ë‹¹ ë…¸ë“œë¥¼ ê±°ì³ ë‹¤ë¥¸ ë…¸ë“œë¡œ ê°€ëŠ” ë¹„ìš©ì„ ê³„ì‚°í•˜ì—¬ ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸”ì„ ê°±ì‹ í•œë‹¤.
> 5. 3,4ë²ˆ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.

- ê° ë…¸ë“œì— ëŒ€í•œ í˜„ì¬ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ ì •ë³´ë¥¼ 1ì°¨ì› ë¦¬ìŠ¤íŠ¸ (ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸”)ì— ì €ì¥í•œë‹¤.

- ë§¤ë²ˆ ì²˜ë¦¬í•˜ê³  ìˆëŠ” í˜„ì¬ ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì£¼ë³€ ê°„ì„ ì„ í™•ì¸í•œë‹¤.
    - ë” ì§§ì€ ê²½ë¡œë¥¼ ì°¾ìœ¼ë©´ => ê°±ì‹ 
- ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì¤‘ í˜„ì¬ ìµœë‹¨ ê±°ë¦¬ê°€ ê°€ì¥ ì§§ì€ ë…¸ë“œë¥¼ í™•ì¸í•´ => 4ë²ˆ ê³¼ì •ì„ ìˆ˜í–‰í•œë‹¤ (ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜)

### ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ ë°©ë²• 2ê°€ì§€

> 1. ì‰¬ìš´ êµ¬í˜„ / ëŠë¦° ë™ì‘ : O(V^2)
> 2. ê¹Œë‹¤ë¡œìš´ êµ¬í˜„ / ë¹ ë¥¸ ë™ì‘ : O(E * logV)


#### 1. ê°„ë‹¨í•œ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜

- V : ë…¸ë“œì˜ ê°œìˆ˜

- 1ì°¨ì› ë¦¬ìŠ¤íŠ¸ : ê° ë…¸ë“œì— ëŒ€í•œ ìµœë‹¨ê±°ë¦¬ë¥¼ ë‹´ëŠ”ë‹¤.
- ìµœë‹¨ê±°ë¦¬ê°€ ê°€ì¥ ì§§ì€ ë…¸ë“œë¥¼ ì„ íƒí•˜ê¸°ìœ„í•´ ë§¤ ë‹¨ê³„ë§ˆë‹¤ 1ì°¨ì› ë¦¬ìŠ¤íŠ¸ì˜ ì›ì†Œë¥¼ ìˆœì°¨ íƒìƒ‰

```python
import sys

input = sys.stdin.readline
INF = int(1e9)

# ë…¸ë“œì˜ ê°œìˆ˜, ê°„ì„ ì˜ ê°œìˆ˜
n, m = map(int, input.split())
# ì‹œì‘ ë…¸ë“œ ë²ˆí˜¸ ì…ë ¥ë°›ê¸°
start = int(input())
# ê° ë…¸ë“œì— ì—°ê²°ë˜ì–´ ìˆëŠ” ë…¸ë“œì— ëŒ€í•œ ì •ë³´ë¥¼ ë‹´ëŠ” 1ì°¨ì› ë¦¬ìŠ¤íŠ¸
graph = [[] for i in range(n + 1)]
# ë°©ë¬¸í•œ ì ì´ ìˆëŠ”ì§€ ì²´í¬í•˜ëŠ” ëª©ì ì˜ ë¦¬ìŠ¤íŠ¸ 
visited = [False] * (n + 1)
# ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸”ì„ ëª¨ë‘ ë¬´í•œìœ¼ë¡œ ì´ˆê¸°í™”
distance = [INF] * (n + 1)

# ëª¨ë“  ê°„ì„  ì •ë³´ë¥¼ ì…ë ¥ë°›ê¸°
for _ in range(m):
    # aë²ˆ ë…¸ë“œì—ì„œ bë²ˆ ë…¸ë“œë¡œ ê°€ëŠ” ë¹„ìš©ì´ c
    a, b, c = map(int, input().split())
    graph[a].append((b, c))


# ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì¤‘ ê°€ì¥ ìµœë‹¨ ê±°ë¦¬ê°€ ì§§ì€ ë…¸ë“œì˜ ë²ˆí˜¸ë¥¼ ë°˜í™˜
def get_smallest_node():
    min_value = INF
    # ê°€ì¥ ìµœë‹¨ ê±°ë¦¬ê°€ ì§§ì€ ë…¸ë“œ(ì¸ë±ìŠ¤)
    index = 0

    # ğŸ’¥ì‹œê°„ë³µì¡ë„ omg
    for i in range(1, n + 1):
        if distance[i] < min_value and not visited[i]:
            min_value = distance[i]
            index = i
    return index


def dijkstra(start):
    # ì‹œì‘ ë…¸ë“œ ì´ˆê¸°í™”
    distance[start] = 0
    visited[start] = True

    # startë²ˆ ë…¸ë“œì—ì„œ j[0]ë²ˆ ë…¸ë“œë¡œ ê°€ëŠ” ë¹„ìš© : j[1]
    for j in graph[start]:
        distance[j[0]] = j[1]

    for i in range(n - 1):
        now = get_smallest_node()
        visited[now] = True

        # ğŸ’¥ì‹œê°„ë³µì¡ë„ omg
        # í˜„ì¬ ë…¸ë“œ nowì™€ ì—°ê²°ëœ ë‹¤ë¥¸ ë…¸ë“œ í™•ì¸
        for j in graph[now]:
            # cost : í˜„ì¬ ë…¸ë“œnowë¥¼ ê±°ì³ ë‹¤ìŒ ë…¸ë“œ j[1]ìœ¼ë¡œ ê°€ëŠ” ê±°ë¦¬
            cost = distance[now] + j[1]
            # distance[j[0]] : j[0]ê¹Œì§€ ê°€ëŠ” ìµœë‹¨ ê±°ë¦¬
            if cost < distance[j[0]]:
                distance[j[0]] = cost


dijkstra(start)

```

#### 2. ê°œì„ ëœ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜

- V : ë…¸ë“œì˜ ê°œìˆ˜
  
- E : ê°„ì„ ì˜ ê°œìˆ˜
- ìµœë‹¨ ê±°ë¦¬ê°€ ê°€ì¥ ì§§ì€ ë…¸ë“œë¥¼ ì°¾ëŠ” ë°©ë²• : Heap ìë£Œêµ¬ì¡° ì‚¬ìš©
- **Heap**

> - ìš°ì„ ìˆœìœ„ í êµ¬í˜„ì— ì‚¬ìš©ë˜ëŠ” ìë£Œêµ¬ì¡°
>   - ìš°ì„ ìˆœìœ„ í : ìš°ì„ ìˆœìœ„ê°€ ê°€ì¥ ë†’ì€ ë°ì´í„°ë¥¼ ê°€ì¥ ë¨¼ì € ì‚­ì œ
> - íŒŒì´ì¬ì—ì„œ *PriorityQueue* ë˜ëŠ” ***heapq*** ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©
>   - **heapq** : íŠœí”Œì„ ì›ì†Œë¡œ ë°›ìœ¼ë©´, íŠœí”Œì˜ ì²«ë²ˆì¨° ì›ì†Œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìš°ì„ ìˆœìœ„ íë¥¼ êµ¬ì„±í•œë‹¤.
> - ìµœì†Œí™(Min Heap) : ê°’ì´ ë‚®ì€ ë°ì´í„°ê°€ ë¨¼ì € ì‚­ì œë¨ 
>   - âœ…íŒŒì´ì¬ì—ì„œ ê¸°ë³¸ì ìœ¼ë¡œ ìµœì†Œ í™ êµ¬ì¡°ë¥¼ ì´ìš©
>   - ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ : ë¹„ìš©ì´ ì ì€ ë…¸ë“œë¥¼ ìš°ì„ íƒìƒ‰í•˜ë¯€ë¡œ, ìµœì†Œ í™ êµ¬ì¡°ê°€ ì í•©í•˜ë‹¤
> - ìµœëŒ€í™(Max Heap) : ê°’ì´ í° ë°ì´í„°ê°€ ë¨¼ì € ì‚­ì œë¨
>   - ìµœì†Œí™ì„ ìµœëŒ€í™ì²˜ëŸ¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²• : ìš°ì„ ìˆœìœ„ ê°’ì— ìŒì˜ ë¶€í˜¸ë¥¼ ë¶™í˜€ ë„£ê³ , êº¼ë‚¸ ë’¤ ë‹¤ì‹œ ìŒì˜ ë¶€í˜¸ë¥¼ ë¶™ì—¬ ì›ë˜ì˜ ê°’ìœ¼ë¡œ ëŒë¦°ë‹¤.
> - ìš°ì„ ìˆœìœ„ í êµ¬í˜„ë°©ì‹

|ìš°ì„ ìˆœìœ„ í êµ¬í˜„ ë°©ì‹|ì‚½ì…ì‹œê°„|ì‚­ì œì‹œê°„|
|----|----|----|
|ë¦¬ìŠ¤íŠ¸|O(1)|O(N)|
|í™|O(logN)|O(logN)|

- ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì—ì„œì˜ ìš°ì„ ìˆœìœ„ í : í˜„ì¬ ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œë¥¼ ì €ì¥í•˜ê¸° ìœ„í•œ ëª©ì 
  
  - ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œ = ìš°ì„ ìˆœìœ„ íì—ì„œ ê·¸ëƒ¥ pop í•œ ë…¸ë“œ
  
  - ìµœë‹¨ ê±°ë¦¬ê°€ ê°€ì¥ ì§§ì€ ë…¸ë“œë¥¼ íƒìƒ‰í•˜ëŠ” ê³¼ì •ì´ í•„ìš” ì—†ì–´ì§„ë‹¤
  - get_smallest_node() í•¨ìˆ˜ê°€ í•„ìš” ì—†ë‹¤
  
```python
import heapq
import sys

input = sys.stdin.readline
INF = int(1e9)

n,m = map(int, input().split())
start = int(input())

graph = [[] for i in range(n+1)]

distance = [INF] * (n+1)

for _ in range(m):
    a,b,c = map(int,input().split())
    graph[a].append((b,c))

def dijkstra(start):
    q = []
    heapq.heappush(q,(0,start))
    distance[start] = 0
    
    while q:
        dist, now = heapq.heappop(q)
        if dist > distance[now]:
            continue
    
        for i in graph[now]:
            cost = dist + i[1]
            if distance[i[0]] > cost:
                distance[i[0]] = cost
                heapq.heappush(q,(cost, i[0]))

dijkstra(start)
```


## í”Œë¡œì´ë“œ ì›Œì…œ ì•Œê³ ë¦¬ì¦˜

- ëª¨ë“  ì§€ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì§€ì ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ ëª¨ë‘ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ : O(N^3)

- ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ vs í”Œë¡œì´ë“œ ì›Œì…œ ì•Œê³ ë¦¬ì¦˜
  - ë‹¤ìµìŠ¤íŠ¸ë¼
  >  - ë‹¨ê³„ë§ˆë‹¤ ìµœë‹¨ ê±°ë¦¬ë¥¼ ê°€ì§€ëŠ” ë…¸ë“œë¥¼ í•˜ë‚˜ì”© ë°˜ë³µì ìœ¼ë¡œ ì„ íƒ
  >  - í•´ë‹¹ ë…¸ë“œë¥¼ ê±°ì³ê°€ëŠ” ê²½ë¡œë¥¼ í™•ì¸ í›„
  >  - ìµœë‹¨ ê±°ë¦¬ í…Œì´ë¸”ì„ ê°±ì‹ 
  >  - ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜

  - í”Œë¡œì´ë“œ ì›Œì…œ
  >  - ê±°ì³ê°€ëŠ” ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì•Œê³ ë¦¬ì¦˜ ìˆ˜í–‰
  >  - ë§¤ë²ˆ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì¤‘ì—ì„œ ìµœë‹¨ ê±°ë¦¬ë¥¼ ì°¾ì„ í•„ìš”ê°€ ì—†ë‹¤ âœ… 
  >  - ë‹¤ì´ë‚˜ë¯¹ í”„ë¡œê·¸ë˜ë° => **ì í™”ì‹**
  >    - Dab = min(Dab, Dak + Dkb)
  
  | Dab                        | Dak + Dkb                       |
  | -------------------------- | ------------------------------- |
  | (A -> B) ë¡œ ê°€ëŠ” ìµœì†Œ ë¹„ìš© | (A -> K -> B) ë¡œ ê°€ëŠ” ìµœì†Œ ë¹„ìš© |

- ê·¸ë¦¼
  
  ![img.png](img.png)
  ![img_1.png](img_1.png)
```python
INF = int(1e9)

# ë…¸ë“œ ê°œìˆ˜ & ê°„ì„  ê°œìˆ˜
n = int(input())
m = int(input())

# 2ì°¨ì› ë¦¬ìŠ¤íŠ¸(ê·¸ë˜í”„ í‘œí˜„)
graph = [[INF]*(n+1) for _ in range(n+1)]

# ìê¸° ìì‹ ìœ¼ë¡œ ê°€ëŠ” ê²½ë¡œ ë¹„ìš© = 0
for a in range(n+1):
    for b in range(n+1):
        if a==b:
            graph[a][b]=0

# ê° ê°„ì„ ì— ëŒ€í•œ ì •ë³´ ì…ë ¥
for _ in range(m):
    a,b,c = map(int,input().split())
    graph[a][b] = c

# ì í™”ì‹ì— ë”°ë¼ í”Œë¡œì´ë“œ ì›Œì…œ ì•Œê³ ë¦¬ì¦˜ ìˆ˜í–‰
for k in range(1, n+1):
    for a in range(1,n+1):
        for b in range(1,n+1):
            # ì í™”ì‹ ê·¸ëŒ€ë¡œ
            graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])
```