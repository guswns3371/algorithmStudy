# 다이나믹 프로그래밍

## 중복되는 연산 줄이기

* 연산속도와 메모리 공간을 최대한을 활용할 수 있는 알고리즘을 작성해야 한다.
    * 메모리 공간을 약간 더 사용하면 연산속도를 비약적으로 증가시킬 수 있는 방법이 "다이나믹 프로그래밍(동적 계획법)"이다.

### 다이나믹 프로그래밍의 기본적인 아이디어

#### 예시 : 피보나치 수열

* 피보나치 수열 f(n) = f(n-1) + f(n-2), f(1) =1, f(2) =1

* f(4)의 값을 구하기위해서 f를 반복해서 호출해야한다.
    * f(1) 또는 f(2)를 만나면 호출을 정지한다.
    * 재귀함수를 통해 구현할 수 있다.
* 코드

```python
def fibo(n):
    if n == 1 or n == 2:
        return 1
    return fibo(n - 1) + fibo(n - 2)
```

* 일반적인 피보나치 수열의 문제점
    * n의 값이 커지면 수행시간이 기하급수적으로 늘어난다.
    * 해결 방안
        * 동일한 함수가 반복적으로 호출되는 것을 메모이제이션을 통해 해결한다

### 메모이제이션

* 먼저 다이나믹 프로그래밍을 사용할 수 있는 조건은 2가지가 있다.
    1. 큰 문제를 작은 문제로 나눌 수 있다.
    2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

* 메모이제이션
    * 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, 한번 구한 결과를 메모리 공간에 메모해두고 가은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법이다.
    * 값을 저장하는 방법이므로 "캐싱"이라고도 한다.
    * 계산된 결과를 일시적으로 기록해 놓은 넓은 개념을 의미한다.
        * 다이나믹 프로그래밍과는 별도의 개념이다.
    * 구현방법
        * 한번 구한 정보를 리스트에 저장한다.
    * 때에 따라 리스트가 아닌 dict(사전형)자료형을 이용할 수 있다.
        * 수열처럼 연속적이지 않은 경우에 사용된다.

* 메모이제이션을 이용한 피보나치 코드

```python
d = [0] * 100


def fibo(n):
    if n == 1 or n == 2:
        return 1

    if d[n] != 0:  # 존재하는 메모가 있으면 활용한다
        return d[n]

    d[n] = fibo(n - 1) + fibo(n - 2)  # 메모하는 부분
    return d[n]
```

### 다이나믹 프로그래밍의 2가지 방식 : 탑다운, 보텀업

* 탑다운 방식(Top-Down)
    * 큰 문제를 해결하기 위해 작은 문제를 호출하는 방식
    * 재귀함수를 이용하여 다이나믹 프로그램밍 소스코드를 작성하는 방법이다.
    * 메모이제이션 방식으로 "하향식"이라고도 불린다.
        * 메모이제이션이라는 용어는 탐다운 방식에 국한되어 사용되는 표현이다.
* 탑다운 방식을 따르는 피보나치 소스코드

```python
def fibo(n):
    if n == 1 or n == 2:
        return 1
    return fibo(n - 1) + fibo(n - 2)
```

* 보텀업 방식(Bottom-Up)
    * 작은 문제부터 차근차근 답을 도출하는 방식
    * 단순히 반복문을 이용하여 소스코드를 작성하는 방법이다.
    * "상향식"이라고도 불린다.
    * 보텀업 방식에서 사용되는 결과 저장용 리스트는 'DP 테이블'이라고 불린다.
    * 가능하면 재귀 함수를 이용하는 "탑다운" 보다 반복문을 이용하는 "보텀업" 방식이 권장된다.
        * 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문이다. (recursion depth error)

* 보텀업 방식을 따르는 피보나치 소스코드

```python
d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]
```

