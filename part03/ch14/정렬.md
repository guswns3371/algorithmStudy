# 정렬

## 개요

* 정렬 : 데이터를 특정한 기준에 따라서 순서대로 나열하는 것
* 정렬 알고리즘은 이진 탐색의 전처리 과정이다.
    * 종류 : 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬
    * 파이썬에서는 기본 정렬 라이브러리를 적용한 효과적인 정렬이 가능하다.

* 데이터

|카드|7|5|9|0|3|1|6|2|4|8|
|---|---|---|---|---|---|---|---|---|---|---|  

## 선택 정렬

* 매번 가장 작은 것은 선택하는 원시적인 정렬 알고리즘이다.

### 설명

* 데이터

|카드|7|5|9|0|3|1|6|2|4|8|
|---|---|---|---|---|---|---|---|---|---|---|  

* 0단계

> 전체 카드 중 가장 작은 0을 선택하여 맨 앞 7과 바꾼다

|0단계|0|5|9|7|3|1|6|2|4|8|
|---|---|---|---|---|---|---|---|---|---|---|  

* 1단계

> 정렬된 첫번쨰를 제외하고 이후 카드 중 가장 작은 1을 선택하여 처리안된 데이터 중 가장 앞 5와 바꾼다

|1단계|0|1|9|7|3|5|6|2|4|8|
|---|---|---|---|---|---|---|---|---|---|---|

* 2단계

> 정렬된 데이터를 제외하고 이후 카드 중 가장 작은 2을 선택하여 처리안된 데이터 중 가장 앞 9와 바꾼다

|2단계|0|1|2|7|3|5|6|9|4|8|
|---|---|---|---|---|---|---|---|---|---|---|

*** 중략 ***

* 8단계

> 정렬된 데이터를 제외하고 이후 카드 중 가장 작은 8을 선택하여 처리안된 데이터 중 가장 앞 9와 바꾼다

|8단계|0|1|2|3|4|5|6|7|9|8|
|---|---|---|---|---|---|---|---|---|---|---|

* 9단계

> 정렬을 마친다

|9단계|0|1|2|3|4|5|6|7|8|9|
|---|---|---|---|---|---|---|---|---|---|---|

### 코드

```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    # min_index는 i단계에서 정렬되지 않은 데이터중 가장 작은 데이터이다.
    min_index = i
    for j in range(i + 1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    # swap 코드
    array[i], array[min_index] = array[min_index], array[i]
```

### 시간복잡도

* O(N^2)
    * 퀵 정렬, 기본 정렬 라이브러리에 비해 매우 비효율적이다.
    * 특정 리스트에서 작은 데이터를 찾을 떄 선택정렬이 자주 이용된다.

## 삽입 정렬

* 특정 데이터를 필요할 떄만 적절한 위치에 삽입하는 정렬 알고리즘이다
    * 삽입 정렬은 데이터가 거의 정렬되어있을 떄 효율적인 알고리즘이다.
    * 특정한 데이터가 적절한 위치에 들어가기 전에, 그 앞까지의 데이터는 이미 정렬되어있다고 가정한다.

### 설명

* 데이터

|카드|7|5|9|0|3|1|6|2|4|8|
|---|---|---|---|---|---|---|---|---|---|---|  

* 0단계

> * 삽입 정렬은 두번째 데이터부터 시작한다. 그 이유는 첫 번째 데이터는 그 자체로 정렬되어 있다고 판단하기 때문이다.
> * 첫번쨰 데이터 7은 그자체로 정렬되어 있다고 판단하고, 두번째 데이터인 5가 들어갈 위치를 판단한다.
> * 7의 왼쪽 혹은 오른쪽으로 들어가는 경우가 존재한다. 오름차순으로 카드를 정렬하기 떄문에 7의 왼쪽에 정렬한다.

|0단계|5|7|9|0|3|1|6|2|4|8|
|---|---|---|---|---|---|---|---|---|---|---|  

* 1단계

> 9가 어떤 위치에 들어갈지 판단한다. 삽입될 수 있는 위치는 총 3가지이다
> * _ 5 _ 7 _ 90316248 : _ 부분이 9가 삽입될 수 있는 자리
> * 9는 5와 7보다 크므로 원래 그 자리 그대로 둔다

|1단계|5|7|9|0|3|1|6|2|4|8|
|---|---|---|---|---|---|---|---|---|---|---| 

* 2단계

> 0이 어떤 위치에 들어갈지 판단한다. 삽입될 수 있는 위치는 총 4가지이다
> * _ 5 _ 7 _ 9 _ 0316248 : _ 부분이 0이 삽입될 수 있는 자리
> * 0은 5,7,9보다 작으로 5의 왼쪽에 삽입한다.

|2단계|0|5|7|9|3|1|6|2|4|8|
|---|---|---|---|---|---|---|---|---|---|---| 

* 위와 같은 과정을 N - 1 번 반복하면 모든 데이터가 정렬된다.
* 정렬이 이뤄진 원소는 항상 오름차순을 유지하고 있다.
    * 다시 말해, 매단계에서 왼쪽 부분의 카드들은 항상 오름차순으로 정렬된 상태이다.
    * 이러한 특징때문에 삽입될 데이터보다 작은 데이터를 만나면 그 위치에서 멈추면 된다.

### 코드

```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)):
    for j in range(i, 0, -1):
        if array[j] < array[j - 1]:
            array[j], array[j - 1] = array[j - 1], array[j]
        else:
            break
```

### 시간복잡도

* O(N^2)
* 데이터가 거의 정렬되어 있는 상태인 경우 매우 빠르게 동작하다.
    * 보통은 비효율적이지만 정렬이 거의 되어있는 상황에서는 강력하다

## 퀵 정렬

* 가장 많이 사용되는 알고리즘이다.
* 기준 데이터(피벗)을 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾼다.

### 설명

* 호어 분할 방식의 퀵 정렬 (리스트에서 첫 번째 데이터를 피버으로 정한다)
    1. 리스트에서 첫번쨰 데이터를 피벗으로 정한다.
    2. 왼쪽부터는 피벗보다 큰 데이터를 찾는다.
    3. 오른쪽부터는 피벗보다 작은 데이터를 찾는다.
    4. 그리고 큰 데이터와 작은 데이터의 위치를 서로 교환해준다.
    5. 이와 같은 과정을 반복한다.

* 3개의 파트로 나눠서 생각한다.

#### I.

* 0단계

> * 첫 번째 데이터를 피벗으로 설정한다. 피벗 = 5
> * 이후 왼쪽부터 피벗(5)보다 큰 데이터를 선택한다 -> 7
> * 오른쪽부터 피벗(5)보다 작은 데이터를 선택한다 -> 4
> * 이 두 데이터의 위치를 바꾼다.

|카드|5|7|9|0|3|1|6|2|4|8|
|---|---|---|---|---|---|---|---|---|---|---|  
|0단계|5|4|9|0|3|1|6|2|7|8|

* 1단계

> * 다시 피벗보다 큰 데이터와 작은 데이터를 각각 찾는다.
> * 이후 왼쪽부터 피벗(5)보다 큰 데이터를 선택한다 -> 9
> * 오른쪽부터 피벗(5)보다 작은 데이터를 선택한다 -> 2
> * 이 두 데이터의 위치를 바꾼다.

|0단계|5|4|9|0|3|1|6|2|7|8|
|---|---|---|---|---|---|---|---|---|---|---|  
|1단계|5|4|2|0|3|1|6|9|7|8|

* 2단계

> * 다시 피벗보다 큰 데이터와 작은 데이터를 각각 찾는다.
> * 이후 왼쪽부터 피벗(5)보다 큰 데이터를 선택한다 -> 6
> * 오른쪽부터 피벗(5)보다 작은 데이터를 선택한다 -> 1
> * **여기서 현재 왼쪽 부터 찾는 값과 오른쪽 부터 찾는 값의 위치가 서로 엇갈린다.**
> * _두 값이 엇갈린 경우에는 '작은 데이터' 와 '피벗' 의 위치를 변경한다._
> * 이 두 데이터의 위치를 바꾼다.

|1단계|5|4|2|0|3|1|6|9|7|8|
|---|---|---|---|---|---|---|---|---|---|---|  
|2단계|1|4|2|0|3|5|6|9|7|8|

* 3단계

> * 분할 완료된 상태이다.
> * 피벗(5) 기준으로 왼쪽에 있는 데이터는 피벗보다 작고, 오른쪽에 있는 데이터는 피벗보다 크다.
> * 이 작업이 분할 또는 파티션이라고 한다.
> * 이러한 상태에서 왼쪽 리스트와 오른쪽 리스트를 개별적으로 정렬시킨다.
> * 왼쪽 리스트, 오른쪽 리스트를 정렬할 때 각각 피벗을 설정하여 동일한 방식으로 정렬을 수행한다.

#### II.

* 왼쪽 리스트에서 I 파트와 동일한 과정으로 정렬을 수행한다.

#### III.

* 오른쪽 리스트에서 I 파트와 동일한 과정으로 정렬을 수행한다.

### 코드

* 재귀함수로 작성했을 경우 구현이 매우 간결해진다.
* 재귀함수에는 종료조건이 필수이다. 퀵 정렬이 끝나는 조건은 **현재 리스트의 원소의 개수가 1개인 경우이다.**
    * 원소가 1개라면, 이미 정렬이 되어있다고 간주할 수 있고, 분할이 불가능하다.

```python
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]


def quick_sort(array, start, end):
    if start >= end:
        return

    pivot = start
    left = start + 1
    right = end

    while array[left] < array[pivot] and left <= end:
        left += 1
    while array[right] >= array[pivot] and right > start:
        right -= 1

    if left <= right:
        array[left], array[right] = array[right], array[left]
    else:
        array[left], array[pivot] = array[pivot], array[left]

    quick_sort(array, start, right - 1)
    quick_sort(array, right + 1, end)


quick_sort(array, 0, len(array) - 1)
print(array)
```

* 파이썬의 장점을 살린 코드 (비효율적이지만 직관적임)

```python
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]


def quick_sort(array):
    if len(array) <= 1:
        return array

    pivot = array[0]
    tail = array[1:]

    left_side = [i for i in tail if i <= pivot]
    right_side = [j for j in tail if j > pivot]

    return quick_sort(left_side) + [pivot] + quick_sort(right_side)


print(quick_sort(array))
```

### 시간복잡도

* O(NlogN) : 평균적인 시간 복잡도
    * O(N^2) : 최악의 경우의 시간 복잡도

* 삽입 정렬과 다르게 이미 정렬되어있는 데이터에 대해선 퀵 정렬은 매우 느리게 동작한다.

## 계수 정렬

### 설명

* 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다.
    * 데이터의 개수가 N, 데이터 중 최댓값이 K일 경우 계수 정렬은 최악의 경우에도 수행시간 O(N + K)를 보장한다.
    * 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 떄만 사용할 수 있다.
    * 가장 큰 데이터와 가장 작은 데이터의 차이가 너무 크면 계수 정렬을 사용할 수 없다. (1,000,000을 넘지 않아야한다.)

* 데이터를 비교하는게 아니라 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는다.


* 초기단계 : 7 5 9 0 3 1 6 2 9 1 4 8 0 5 2

* 1단계

> 7을 확인하여 7과 동일한 인덱스의 데이터를 1씩 증가한다

|0|1|2|3|4|5|6|7|8|9|
|---|---|---|---|---|---|---|---|---|---|
|0|0|0|0|0|0|0|1|0|0|

* 2단계

> 5을 확인하여 5과 동일한 인덱스의 데이터를 1씩 증가한다

|0|1|2|3|4|5|6|7|8|9|
|---|---|---|---|---|---|---|---|---|---|
|0|0|0|0|0|1|0|1|0|0|

** 과정 반복 **

* 15단계

> 2을 확인하여 2과 동일한 인덱스의 데이터를 1씩 증가한다

|0|1|2|3|4|5|6|7|8|9|
|---|---|---|---|---|---|---|---|---|---|
|2|2|2|1|1|2|1|1|1|2|

* 결과적으로 리스트에는 각 데이터가 몇번 등장했는지 그 횟수가 기록된다.
* 리스트의 인덱스를 인덱스의 값만큼 출력한다.
    * 00 11 22 3 4 55 6 7 8 99 (정렬된 상태)

### 코드

```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 3, 7, 4, 8, 0, 5, 2]

count = [0] * (max(array) + 1)

for i in range(len(array)):
    count[array[i]] += 1

for i in range(len(count)):
    for j in range(count[i]):
        print(i, end=" ")
```

* 리스트 대신 우선순위 큐를 사용해도 될 꺼 같은데...

### 시간복잡도

* O(N+K) : 데이터의 개수 N, 데이터 중 최대값의 크기 K
* 현존하는 정렬 알고리즘 중에서 기수정렬과 더불어 가장 빠르다.
    * 기수정렬은 계수정렬보다 동작은 느리지만, 처리할 수 있는 정수의 크기가 더 크다. 하지만 원리나 소스코드는 더 복잡하다.

### 공간복잡도

* 심각한 비효율성을 초래할 수 있다.
    * [0,999999]인 경우에도 크기가 100만개가 되도록 리스트를 선언해야한다.

* 데이터 크기가 한정되있고, 많이 중복되어있을 수록 유리하다.

## 파이썬의 정렬 라이브러리

* 기본 정렬 라이브러리 sorted() 함수를 제공한다.
    * 퀵 정렬과 동작 방식이 비슷한 병합 정렬을 기반으로 만들어졌다.
        * 병합 정렬은 일반적으로 퀵 정렬보다 느리지만, 최악의 경우에도 O(NlogN)의 시간 복잡도를 보장한다.

1. sorted()

> result = sorted(array)

2. sort()

> array.sort()

* key 값으로 정렬 기준을 지정할 수 있다.

```python
array = [('바나나', 2), ('사과', 5), ('당근', 3)]


def setting(data):
  return data[1]


result = sorted(array, key=setting)
```
